# OOPS
We don't like to talk about it, but scientists make terrible software developers. They get away with it because their sloppily written code is usually fast -- everything is procedural, hard-coded, and intended to solve exactly one problem exactly one way. Unfortunately, this makes code maintenance a nightmare. The code is hard to use and impossible to read; modifying it to solve a new problem is often the subject of a PhD dissertation. To be frank, this really stinks, and it would be a lot better to have something more flexible.

Object-oriented programming, on the other hand, is not known for its speed. Abstraction adds overhead, so the code is slower. Writing good OOP code can take a long time, so the development is slower. But sometimes you have a simple problem you need to solve, or perhaps you have a new idea you want to try before implementing it in a bigger, better, faster code. If you put in all that hard work to write a nice object-oriented framework, you can basically just copy and paste your problem into the code and watch it go. If only scientists actually wrote object-oriented code...

Now you have OOPS - the Object-Oriented PDE Solver. It's simple, it's easy, and it reduces solving a new PDE to defining a right-hand side routine and boundary conditions. Things like grid setup and interpolation, ODE solvers, and managing memory are abstracted away so you don't have to worry about them. At the same time, you <i>could</i> worry about them if you wanted to; if the standard RK4 solver isn't enough for you, and what you <i>really</i> need is an adaptive implicit solver for your chemical reactions, you can write that, too, and see it automatically work with everything else.

Is it the fastest kid on the block? Probably not. Will you get your code working faster? Almost certainly.
